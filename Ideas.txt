Приветствую, Дмитрий! Можно сначала получить объединение всех ключей из двух словарей, отсортировать их, а затем уже перебирать эти ключи и смотреть, что произошло с каждым из них

Добрый день, вам нужно построить разницу между двумя словарями, но ваша структура должна быть такой, чтобы вам удобно было дальше по ней строить вывод.

То есть, необходимо сделать удобное представление, оттуда загнать полученные словари и уже потом сравнивать их.


По построению диффа очень хорошо помогло прохождение испытания Вычислитель различий в Словарях и множествах. Это прям очень подходит для плоских словарей, то есть третьего шага. А вот для шестого шага к этому потребовалось прикрутить рекурсию (что прям взрывало мне мозг и конкретно дизморалило), а так же поправить условия для ' ', '+', '-' для тех ключей, которые есть в обоих словарях и их значения это словари. А для для stylish хорошо подходит рекомендованное в шестом шаге испытание


Здравствуйте, Алексей. Все верно, форматтер это функция, которая форматирует наши обработанные данные и приводит их в нужный вид (или даже в три разных, как в этом проекте), аргумент format как раз и задает какой вид будет на выходе.

Да, все верно. Stylish будет выводить вашу структуру разниц в нужный нам вид (с отступами, без кавычек).

Да, он должен быть форматером по умолчанию как для библиотеки (вы же помните, что gendiff можно будет еще использовать как библиотеку?), так и в консольной утилите.

Gunlinux, приветствую!

    но дефолтный парсер без создания модификатора парсера подгружает, значение null (указанное в тестовых фикстурах), подгружает как None

Это нормальное поведение. Сравниваются ведь полученные словари в результате парсинга, а не сами файлы, и для этого удобно будет использовать встроенные типы python. Но тут появляется другая задача - это вывод полученного дифа. И тут стоит обратить внимание на то, что за вывод отвечает форматер, и именно его задача показать в выводе те же None значения как null.


Должна возвращаться строка и не None, a null, не False, а false. Неужели надо все эти значения в ифах менять??
Да, верно. Удобно вынести эти преобразования в отдельную функцию. Ведь это по факту приведение, например, булева значения к строке.

